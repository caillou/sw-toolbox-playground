<!DOCTYPE html><html><head><link rel="stylesheet" href="/main.css"></head><body><h1>Path-to-RegExp</h1><blockquote>
<p>Turn an Express-style path string such as <code>/user/:name</code> into a regular expression.</p>
</blockquote>
<p><a href="https://npmjs.org/package/path-to-regexp"><img src="https://img.shields.io/npm/v/path-to-regexp.svg?style=flat" alt="NPM version"></a>
<a href="https://travis-ci.org/pillarjs/path-to-regexp"><img src="https://img.shields.io/travis/pillarjs/path-to-regexp.svg?style=flat" alt="Build status"></a>
<a href="https://coveralls.io/r/pillarjs/path-to-regexp?branch=master"><img src="https://img.shields.io/coveralls/pillarjs/path-to-regexp.svg?style=flat" alt="Test coverage"></a>
<a href="https://david-dm.org/pillarjs/path-to-regexp"><img src="http://img.shields.io/david/pillarjs/path-to-regexp.svg?style=flat" alt="Dependency Status"></a>
<a href="LICENSE.md"><img src="http://img.shields.io/npm/l/path-to-regexp.svg?style=flat" alt="License"></a>
<a href="https://npmjs.org/package/path-to-regexp"><img src="http://img.shields.io/npm/dm/path-to-regexp.svg?style=flat" alt="Downloads"></a></p>
<h2>Installation</h2><pre><code>npm install path-to-regexp --save
</code></pre><h2>Usage</h2><pre><code class="language-javascript">var pathToRegexp = require(&#39;path-to-regexp&#39;)

// pathToRegexp(path, keys, options)
// pathToRegexp.parse(path)
// pathToRegexp.compile(path)
</code></pre>
<ul>
<li><strong>path</strong> An Express-style string, an array of strings, or a regular expression.</li>
<li><strong>keys</strong> An array to be populated with the keys found in the path.</li>
<li><strong>options</strong><ul>
<li><strong>sensitive</strong> When <code>true</code> the route will be case sensitive. (default: <code>false</code>)</li>
<li><strong>strict</strong> When <code>false</code> the trailing slash is optional. (default: <code>false</code>)</li>
<li><strong>end</strong> When <code>false</code> the path will match at the beginning. (default: <code>true</code>)</li>
<li><strong>delimiter</strong> Set the default delimiter for repeat parameters. (default: <code>&#39;/&#39;</code>)</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">var keys = []
var re = pathToRegexp(&#39;/foo/:bar&#39;, keys)
// re = /^\/foo\/([^\/]+?)\/?$/i
// keys = [{ name: &#39;bar&#39;, prefix: &#39;/&#39;, delimiter: &#39;/&#39;, optional: false, repeat: false, pattern: &#39;[^\\/]+?&#39; }]
</code></pre>
<p><strong>Please note:</strong> The <code>RegExp</code> returned by <code>path-to-regexp</code> is intended for use with pathnames or hostnames. It can not handle the query strings or fragments of a URL.</p>
<h3>Parameters</h3><p>The path string can be used to define parameters and populate the keys.</p>
<h4>Named Parameters</h4><p>Named parameters are defined by prefixing a colon to the parameter name (<code>:foo</code>). By default, the parameter will match until the following path segment.</p>
<pre><code class="language-js">var re = pathToRegexp(&#39;/:foo/:bar&#39;, keys)
// keys = [{ name: &#39;foo&#39;, prefix: &#39;/&#39;, ... }, { name: &#39;bar&#39;, prefix: &#39;/&#39;, ... }]

re.exec(&#39;/test/route&#39;)
//=&gt; [&#39;/test/route&#39;, &#39;test&#39;, &#39;route&#39;]
</code></pre>
<p><strong>Please note:</strong> Named parameters must be made up of &quot;word characters&quot; (<code>[A-Za-z0-9_]</code>).</p>
<pre><code class="language-js">var re = pathToRegexp(&#39;/(apple-)?icon-:res(\\d+).png&#39;, keys)
// keys = [{ name: 0, prefix: &#39;/&#39;, ... }, { name: &#39;res&#39;, prefix: &#39;&#39;, ... }]

re.exec(&#39;/icon-76.png&#39;)
//=&gt; [&#39;/icon-76.png&#39;, undefined, &#39;76&#39;]
</code></pre>
<h4>Modified Parameters</h4><h5>Optional</h5><p>Parameters can be suffixed with a question mark (<code>?</code>) to make the parameter optional. This will also make the prefix optional.</p>
<pre><code class="language-js">var re = pathToRegexp(&#39;/:foo/:bar?&#39;, keys)
// keys = [{ name: &#39;foo&#39;, ... }, { name: &#39;bar&#39;, delimiter: &#39;/&#39;, optional: true, repeat: false }]

re.exec(&#39;/test&#39;)
//=&gt; [&#39;/test&#39;, &#39;test&#39;, undefined]

re.exec(&#39;/test/route&#39;)
//=&gt; [&#39;/test&#39;, &#39;test&#39;, &#39;route&#39;]
</code></pre>
<h5>Zero or more</h5><p>Parameters can be suffixed with an asterisk (<code>*</code>) to denote a zero or more parameter matches. The prefix is taken into account for each match.</p>
<pre><code class="language-js">var re = pathToRegexp(&#39;/:foo*&#39;, keys)
// keys = [{ name: &#39;foo&#39;, delimiter: &#39;/&#39;, optional: true, repeat: true }]

re.exec(&#39;/&#39;)
//=&gt; [&#39;/&#39;, undefined]

re.exec(&#39;/bar/baz&#39;)
//=&gt; [&#39;/bar/baz&#39;, &#39;bar/baz&#39;]
</code></pre>
<h5>One or more</h5><p>Parameters can be suffixed with a plus sign (<code>+</code>) to denote a one or more parameter matches. The prefix is taken into account for each match.</p>
<pre><code class="language-js">var re = pathToRegexp(&#39;/:foo+&#39;, keys)
// keys = [{ name: &#39;foo&#39;, delimiter: &#39;/&#39;, optional: false, repeat: true }]

re.exec(&#39;/&#39;)
//=&gt; null

re.exec(&#39;/bar/baz&#39;)
//=&gt; [&#39;/bar/baz&#39;, &#39;bar/baz&#39;]
</code></pre>
<h4>Custom Match Parameters</h4><p>All parameters can be provided a custom regexp, which overrides the default (<code>[^\/]+</code>).</p>
<pre><code class="language-js">var re = pathToRegexp(&#39;/:foo(\\d+)&#39;, keys)
// keys = [{ name: &#39;foo&#39;, ... }]

re.exec(&#39;/123&#39;)
//=&gt; [&#39;/123&#39;, &#39;123&#39;]

re.exec(&#39;/abc&#39;)
//=&gt; null
</code></pre>
<p><strong>Please note:</strong> Backslashes need to be escaped with another backslash in strings.</p>
<h4>Unnamed Parameters</h4><p>It is possible to write an unnamed parameter that only consists of a matching group. It works the same as a named parameter, except it will be numerically indexed.</p>
<pre><code class="language-js">var re = pathToRegexp(&#39;/:foo/(.*)&#39;, keys)
// keys = [{ name: &#39;foo&#39;, ... }, { name: 0, ... }]

re.exec(&#39;/test/route&#39;)
//=&gt; [&#39;/test/route&#39;, &#39;test&#39;, &#39;route&#39;]
</code></pre>
<h4>Asterisk</h4><p>An asterisk can be used for matching everything. It is equivalent to an unnamed matching group of <code>(.*)</code>.</p>
<pre><code class="language-js">var re = pathToRegexp(&#39;/foo/*&#39;, keys)
// keys = [{ name: &#39;0&#39;, ... }]

re.exec(&#39;/foo/bar/baz&#39;)
//=&gt; [&#39;/foo/bar/baz&#39;, &#39;bar/baz&#39;]
</code></pre>
<h3>Parse</h3><p>The parse function is exposed via <code>pathToRegexp.parse</code>. This will return an array of strings and keys.</p>
<pre><code class="language-js">var tokens = pathToRegexp.parse(&#39;/route/:foo/(.*)&#39;)

console.log(tokens[0])
//=&gt; &quot;/route&quot;

console.log(tokens[1])
//=&gt; { name: &#39;foo&#39;, prefix: &#39;/&#39;, delimiter: &#39;/&#39;, optional: false, repeat: false, pattern: &#39;[^\\/]+?&#39; }

console.log(tokens[2])
//=&gt; { name: 0, prefix: &#39;/&#39;, delimiter: &#39;/&#39;, optional: false, repeat: false, pattern: &#39;.*&#39; }
</code></pre>
<p><strong>Note:</strong> This method only works with Express-style strings.</p>
<h3>Compile (&quot;Reverse&quot; Path-To-RegExp)</h3><p>Path-To-RegExp exposes a compile function for transforming an Express-style path into a valid path.</p>
<pre><code class="language-js">var toPath = pathToRegexp.compile(&#39;/user/:id&#39;)

toPath({ id: 123 }) //=&gt; &quot;/user/123&quot;
toPath({ id: &#39;caf√©&#39; }) //=&gt; &quot;/user/caf%C3%A9&quot;
toPath({ id: &#39;/&#39; }) //=&gt; &quot;/user/%2F&quot;

toPath({ id: &#39;:&#39; }) //=&gt; &quot;/user/%3A&quot;
toPath({ id: &#39;:&#39; }, { pretty: true }) //=&gt; &quot;/user/:&quot;

var toPathRepeated = pathToRegexp.compile(&#39;/:segment+&#39;)

toPathRepeated({ segment: &#39;foo&#39; }) //=&gt; &quot;/foo&quot;
toPathRepeated({ segment: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] }) //=&gt; &quot;/a/b/c&quot;

var toPathRegexp = pathToRegexp.compile(&#39;/user/:id(\\d+)&#39;)

toPathRegexp({ id: 123 }) //=&gt; &quot;/user/123&quot;
toPathRegexp({ id: &#39;123&#39; }) //=&gt; &quot;/user/123&quot;
toPathRegexp({ id: &#39;abc&#39; }) //=&gt; Throws `TypeError`.
</code></pre>
<p><strong>Note:</strong> The generated function will throw on invalid input. It will do all necessary checks to ensure the generated path is valid. This method only works with strings.</p>
<h3>Working with Tokens</h3><p>Path-To-RegExp exposes the two functions used internally that accept an array of tokens.</p>
<ul>
<li><code>pathToRegexp.tokensToRegExp(tokens, options)</code> Transform an array of tokens into a matching regular expression.</li>
<li><code>pathToRegexp.tokensToFunction(tokens)</code> Transform an array of tokens into a path generator function.</li>
</ul>
<h4>Token Information</h4><ul>
<li><code>name</code> The name of the token (<code>string</code> for named or <code>number</code> for index)</li>
<li><code>prefix</code> The prefix character for the segment (<code>/</code> or <code>.</code>)</li>
<li><code>delimiter</code> The delimiter for the segment (same as prefix or <code>/</code>)</li>
<li><code>optional</code> Indicates the token is optional (<code>boolean</code>)</li>
<li><code>repeat</code> Indicates the token is repeated (<code>boolean</code>)</li>
<li><code>partial</code> Indicates this token is a partial path segment (<code>boolean</code>)</li>
<li><code>pattern</code> The RegExp used to match this token (<code>string</code>)</li>
<li><code>asterisk</code> Indicates the token is an <code>*</code> match (<code>boolean</code>)</li>
</ul>
<h2>Compatibility with Express &lt;= 4.x</h2><p>Path-To-RegExp breaks compatibility with Express &lt;= <code>4.x</code>:</p>
<ul>
<li>No longer a direct conversion to a RegExp with sugar on top - it&#39;s a path matcher with named and unnamed matching groups<ul>
<li>It&#39;s unlikely you previously abused this feature, it&#39;s rare and you could always use a RegExp instead</li>
</ul>
</li>
<li>All matching RegExp special characters can be used in a matching group. E.g. <code>/:user(.*)</code><ul>
<li>Other RegExp features are not support - no nested matching groups, non-capturing groups or look aheads</li>
</ul>
</li>
<li>Parameters have suffixes that augment meaning - <code>*</code>, <code>+</code> and <code>?</code>. E.g. <code>/:user*</code></li>
</ul>
<h2>TypeScript</h2><p>Includes a <a href="index.d.ts"><code>.d.ts</code></a> file for TypeScript users.</p>
<h2>Live Demo</h2><p>You can see a live demo of this library in use at <a href="http://forbeslindesay.github.com/express-route-tester/">express-route-tester</a>.</p>
<h2>License</h2><p>MIT</p></body></html>